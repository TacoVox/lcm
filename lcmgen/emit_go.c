#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>
#include <string.h>
#include <ctype.h>
#ifdef WIN32
#define __STDC_FORMAT_MACROS			// Enable integer types
#endif
#include <inttypes.h>

#include "lcmgen.h"


#define INDENT(n) (4*(n))

#define emit_start(n, ...) do { fprintf(f, "%*s", INDENT(n), ""); fprintf(f, __VA_ARGS__); } while (0)
#define emit_continue(...) do { fprintf(f, __VA_ARGS__); } while (0)
#define emit_end(...) do { fprintf(f, __VA_ARGS__); fprintf(f, "\n"); } while (0)
#define emit(n, ...) do { fprintf(f, "%*s", INDENT(n), ""); fprintf(f, __VA_ARGS__); fprintf(f, "\n"); } while (0)
#define emit_nl() do { fprintf(f, "\n"); } while (0)

static char *dots_to_underscores(const char *s)
{
    char *p = strdup(s);

    for (char *t=p; *t!=0; t++)
        if (*t == '.')
            *t = '_';

    return p;
}

static void emit_comment(FILE* f, int indent, const char* comment)
{
    if (!comment)
        return;

    gchar** lines = g_strsplit(comment, "\n", 0);
    for (int line = 0; lines[line]; line++) {
        emit(indent, "// %s", lines[line]);
    }

    g_strfreev(lines);
}

static void emit_auto_generated_warning(FILE *f)
{
    fprintf(f,
            "// THIS IS AN AUTOMATICALLY GENERATED FILE.  DO NOT MODIFY\n"
            "// BY HAND!!\n"
            "//\n"
            "// Generated by lcm-gen\n\n");
}

static const char *first_to_upper(const char *str)
{
    char *s = strdup(str);
    s[0] = toupper(s[0]);
    return s;
}

// TODO split into two functions
static const char *map_type_name(const char *t)
{
    if (!strcmp(t,"boolean")) return "bool";
    if (!strcmp(t,"byte")) return "byte";
    if (!strcmp(t,"int8_t")) return "int8";
    if (!strcmp(t,"int16_t")) return "int16";
    if (!strcmp(t,"int32_t")) return "int32";
    if (!strcmp(t,"int64_t")) return "int64";
    if (!strcmp(t,"float")) return "float32";
    if (!strcmp(t,"double")) return "float64";
    if (!strcmp(t,"string")) return "string";

    char *tn = dots_to_underscores(t);
    size_t len = strlen(tn) * 2 + 2;
    char *tm = (char *)malloc(len);
    snprintf(tm, len, "%s.%s", tn, first_to_upper(tn));
    free(tn);
    return tm;
}

static int primitive_type_size (const char *tn)
{
    if (!strcmp ("byte", tn)) return 1;
    if (!strcmp ("boolean", tn)) return 1;
    if (!strcmp ("int8_t", tn)) return 1;
    if (!strcmp ("int16_t", tn)) return 2;
    if (!strcmp ("int32_t", tn)) return 4;
    if (!strcmp ("int64_t", tn)) return 8;
    if (!strcmp ("float", tn)) return 4;
    if (!strcmp ("double", tn)) return 8;
    assert (0);
    return 0;
}

static void emit_conversion_function(FILE *f, const char *type, const char *val,
    int indent)
{
    if (!strcmp(type, "boolean")) {
        emit(indent, "if p.%s {", val);
        emit(indent + 1, "data[offset] = 1");
        emit(indent, "} else {");
        emit(indent + 1, "data[offset] = 0");
        emit(indent, "}");
        emit(indent, "offset += 1");
    }
    else if (!strcmp(type, "byte")) {
        emit(indent, "data[offset] = p.%s", val);
        emit(indent, "offset += 1");
    }
    else if (!strcmp(type, "int8_t")) {
        emit(indent, "data[offset] = byte(p.%s)", val);
        emit(indent, "offset += 1");
    }
    else if (!strcmp(type, "int16_t")) {
        emit(indent, "binary.BigEndian.PutUint16(data[offset:], uint16(p.%s))", val);
        emit(indent, "offset += 2");
    }
    else if (!strcmp(type, "int32_t")) {
        emit(indent, "binary.BigEndian.PutUint32(data[offset:], uint32(p.%s))", val);
        emit(indent, "offset += 4");
    }
    else if (!strcmp(type, "int64_t")) {
        emit(indent, "binary.BigEndian.PutUint64(data[offset:], uint64(p.%s))", val);
        emit(indent, "offset += 8");
    }
    else if (!strcmp(type, "float")) {
        emit(indent, "binary.BigEndian.PutUint32(data[offset:], math.Float32bits(p.%s))", val);
        emit(indent, "offset += 4");
    }
    else if (!strcmp(type, "double")) {
        emit(indent, "binary.BigEndian.PutUint64(data[offset:], math.Float64bits(p.%s))", val);
        emit(indent, "offset += 8");
    }
    else if (!strcmp(type, "string")) {
        emit(indent, "offset += copy(data[offset:], []byte(p.%s))", val);
    }
}

void setup_go_options(getopt_t *gopt)
{
    getopt_add_string (gopt, 0, "go-path",    ".",       "Location for .go files");
}

void emit_go_header(FILE *f, const char *tn)
{
    emit_auto_generated_warning(f);

    emit(0, "package %s", tn);
    emit_nl();
}

int emit_go_enum(lcmgen_t *lcm, lcm_enum_t *le)
{
    char *tn = le->enumname->lctypename;
    char *tn_ = dots_to_underscores(tn);
    char *path = g_strdup_printf("%s/%s_enums.go",
          getopt_get_string(lcm->gopt, "go-path"),
		  tn_);

    if (!lcm_needs_generation(lcm, le->lcmfile, path))
        return 0;

    FILE *f = fopen(path, "w");
    if (f==NULL)
        return -1;

    emit_go_header(f, tn_);
    emit(0, "// TODO");

    free(tn_);

    return 0;
}

// TODO split into smaller functions
int emit_go_struct(lcmgen_t *lcm, lcm_struct_t *ls)
{
    const char *tn = ls->structname->lctypename;
    const char *tn_ = dots_to_underscores(tn);
    const char *tn__ = first_to_upper(tn_);
    const char *path = g_strdup_printf("%s/%s_structs.go",
          getopt_get_string(lcm->gopt, "go-path"),
		  tn_);

    if (!lcm_needs_generation(lcm, ls->lcmfile, path))
        return 0;

    FILE *f = fopen(path, "w");
    if (f==NULL)
        return -1;

    emit_go_header(f, tn_);

    emit(0, "import (");
    emit(1, "\"math\"");
    emit(1, "\"math/bits\"");
    //emit(1, "\"bytes\"");
    emit(1, "\"encoding/binary\"");
    emit(1, "\"fmt\"");
    for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
        lcm_member_t *lm = (lcm_member_t *) g_ptr_array_index(ls->members, m);
        if (!lcm_is_primitive_type (lm->type->lctypename)) {
            emit(1, "\"%s\"", dots_to_underscores(lm->type->lctypename));
        }
    }
    emit(0, ")");
    emit_nl();

    emit(0, "const _ = math.Pi"); // To silence not used warning by go compiler

    // Struct definition
    emit(0, "type %s struct {", tn__);

    for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
        lcm_member_t *lm = (lcm_member_t *) g_ptr_array_index(ls->members, m);

        emit_comment(f, 1, lm->comment);

        int ndim = g_ptr_array_size(lm->dimensions);
        if (ndim == 0) {
            emit(1, "%-20s %s",
                first_to_upper(dots_to_underscores(lm->membername)),
                map_type_name(lm->type->lctypename));
        } else {
            if (lcm_is_constant_size_array(lm)) {
                emit_start(1, "%-20s ",
                    first_to_upper(dots_to_underscores(lm->membername)));
                for (unsigned int d = 0; d < ndim; d++) {
                    lcm_dimension_t *ld = (lcm_dimension_t *) g_ptr_array_index(lm->dimensions, d);
                    emit_continue("[%s]", ld->size);
                }
                emit_end("%s", map_type_name(lm->type->lctypename));
            } else {
                emit_start(1, "%-20s ",
                    first_to_upper(dots_to_underscores(lm->membername)));
                for (unsigned int d = 0; d < ndim; d++)
                    emit_continue("[]");
                emit_end("%s", // TODO add comment on variable name used for size
                    map_type_name(lm->type->lctypename));
            }
        }
    }

    emit(0, "}");
    emit_nl();

    // Functions

    // Deep copy
    emit(0, "// Copy creates a deep copy");
    emit(0, "//func (p *%s) Copy() (%s) {", tn__, tn_);
    emit(1, "// TODO");
    emit(0, "//}");
    emit_nl();

    // Encode
    emit(0, "// Encode encodes a message (fingerprint & data) into binary form");
    emit(0, "//");
    emit(0, "// returns Encoded data or error");
    emit(0, "func (p *%s) Encode() (data []byte, err error) {", tn__);
    emit(1, "size := p.Size()");
    emit(1, "data = make([]byte, 8 + size)");
    emit(1, "binary.BigEndian.PutUint64(data, p.Fingerprint())");
    emit_nl();
    emit(1, "var d []byte");
    emit(1, "if d, err = p.MarshalBinary(); err != nil {");
    emit(2, "return");
    emit(1, "}");
    emit_nl();
    emit(1, "if copied := copy(data[8:], d); copied != size {");
    emit(2, "return data,");
    emit(3, "fmt.Errorf(\"Encoding error, buffer not filled (%%v != %%v)\", copied, size)");
    emit(1, "}");
    emit(1, "return");
    emit(0, "}");
    emit_nl();

    // MarshalBinary
    emit(0, "// MarshalBinary implements the BinaryMarshaller interface");
    emit(0, "func (p *%s) MarshalBinary() (data []byte, err error) {", tn__);
    emit(1, "data = make([]byte, p.Size())");
    emit(1, "offset := 0");
    emit_nl();
    //emit(1, "var buffer bytes.Buffer");
    for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
        lcm_member_t *lm = (lcm_member_t *) g_ptr_array_index(ls->members, m);
        emit_comment(f, 1, lm->comment);
        const char *name = first_to_upper(dots_to_underscores(lm->membername));

        if (lcm_is_primitive_type(lm->type->lctypename)) {
            //emit(1, "if err = binary.Write(&buffer, binary.BigEndian, p.%s); err != nil {",
            //    first_to_upper(dots_to_underscores(lm->membername)));
            //emit(2, "return");
            //emit(1, "}");
            //emit(1, "data = append(data, buffer.Bytes()...)");
            //emit(1, "buffer.Reset()");

            if (! lm->dimensions->len) {
                emit_conversion_function(f, lm->type->lctypename, name, 1);
            } else {
                unsigned int n;
                for (n=0; n<lm->dimensions->len; n++) {
                    lcm_dimension_t *dim =
                        (lcm_dimension_t*) g_ptr_array_index(lm->dimensions, n);
                    if (dim->mode == LCM_VAR) {
                        const char *v = first_to_upper(dim->size);
                        // Needed to make sure i%d and dim->size if of identical type
                        emit(1+n, "i%d := p.%s", n, v);

                        emit(1+n, "for i%d = 0; i%d < p.%s; i%d++ {", n, n,
                            v, n);
                        free((char *)v);
                    } else {
                        emit(1+n, "for i%d := 0; i%d < %s; i%d++ {", n, n,
                            dim->size, n);
                    }
                    emit_conversion_function(f, lm->type->lctypename, name,
                        2+n);
                }
                for (n=lm->dimensions->len; n > 0; n--)
                    emit(n, "}");
            }
        } else {
            if (! lm->dimensions->len) {
                emit(1, "d, e := p.%s.MarshalBinary(); if e != nil {", name);
                emit(2, "return data, e");
                emit(1, "}");
                emit(1, "offset += copy(data[offset:], d)");
            } else {
                unsigned int n;
                GString *array = g_string_new(NULL);
                for (n=0; n<lm->dimensions->len; n++) {
                    lcm_dimension_t *dim =
                        (lcm_dimension_t*) g_ptr_array_index(lm->dimensions, n);
                    g_string_append_printf(array, "[i%d]", n);
                    if (dim->mode == LCM_VAR) {
                        const char *v = first_to_upper(dim->size);
                        emit(1+n, "i%d := p.%s", n, v);

                        emit(1+n, "for i%d = 0; i%d < p.%s; i%d++ {", n, n,
                            v, n);
                        free((char *)v);
                    } else {
                        emit(1+n, "for i%d := 0; i%d < %s; i%d++ {", n, n,
                            dim->size, n);
                    }
                }
                emit(2, "d, e := p.%s%s.MarshalBinary(); if e != nil {", name,
                    array->str);
                emit(3, "return data, e");
                emit(2, "}");
                emit(2, "offset += copy(data[offset:], d)");
                g_string_free(array, TRUE);

                for (n=lm->dimensions->len; n > 0; n--)
                    emit(n, "}");
            }
        }
        emit_nl();
        free((char *)name);
    }
    emit(1, "return");
    emit(0, "}");
    emit_nl();

    // Decode
    emit(0, "// Decode decodes a message (fingerprint & data) from binary form");
    emit(0, "// and verifies that the fingerprint match the expected");
    emit(0, "//");
    emit(0, "// param data The buffer containing the encoded message");
    emit(0, "// returns Error");
    emit(0, "func (p *%s) Decode(data []byte) (err error) {", tn__);
    emit(1, "length := len(data)");
    emit(1, "if length < 8 {");
    emit(2, "return fmt.Errorf(\"Missing fingerprint in buffer\")");
    emit(1, "}");
    emit_nl();
    emit(1, "if fp := binary.BigEndian.Uint64(data[:8]);");
    emit(2, "fp != p.Fingerprint() {");
    emit(2, "return fmt.Errorf(\"Fingerprints does not match (got %%x expected %%x)\",");
    emit(3, "fp, p.Fingerprint())");
    emit(1, "}");
    emit_nl();
    emit(1, "length -= 8");
    emit(1, "size := p.Size()");
    emit(1, "if length != size {");
    emit(2, "return fmt.Errorf(\"Missing data in buffer (size missmatch, got %%v expected %%v)\",");
    emit(3, "length, size)");
    emit(1, "}");
    emit_nl();
    /*
    for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
        lcm_member_t *lm = (lcm_member_t *) g_ptr_array_index(ls->members, m);
        if (lcm_is_primitive_type (lm->type->lctypename)) {
            emit(1, "err = binary.Read(data, binary.BigEndian, &p.%s)",
                first_to_upper(dots_to_underscores(lm->membername)));
        } else {
            emit(1, "err = p.%s.Decode(data)",
                first_to_upper(dots_to_underscores(lm->membername)));
        }
        emit(1, "if err != nil {");
        emit(2, "return err");
        emit(1, "}");
        emit_nl();
    }
    emit(1, "return nil");
    */
    emit(1, "return p.UnmarshalBinary(data[8:])");
    emit(0, "}");
    emit_nl();

    // UnmarshalBinary
    emit(0, "// UnmarshalBinary implements the BinaryUnmarshaler interface");
    emit(0, "func (p *%s) UnmarshalBinary(data []byte) (err error) {", tn__);
    emit(1, "// TODO");
    emit(1, "return fmt.Errorf(\"TODO\")");
    emit(0, "}");
    emit_nl();

    // Fingerprint
    emit(0, "// Fingerprint generates the LCM fingerprint value for this message");
    emit(0, "func (p *%s) Fingerprint(path ...uint64) uint64 {", tn__);
    emit(1, "var fingerprint uint64 = 0x%016"PRIx64, ls->hash);
    emit(1, "for _, v := range path {");
    emit(2, "if v == fingerprint {");
    emit(3, "return 0");
    emit(2, "}");
    emit(1, "}");
    emit_nl();

    emit(1, "path = append(path, fingerprint)");
    emit_start(1, "return bits.RotateLeft64(fingerprint");
    for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
        lcm_member_t *lm = (lcm_member_t *) g_ptr_array_index(ls->members, m);

        if (! lcm_is_primitive_type(lm->type->lctypename)) {
            emit_end(" +");
            emit_start(2, "p.%s.Fingerprint(path...)",
                first_to_upper(dots_to_underscores(lm->membername)));
        }
    }
    emit_end(", 1)");
    emit(0, "}");
    emit_nl();

    // Size
    emit(0, "// Size returns the size of this message in binary form");
    emit(0, "func (p *%s) Size() int {", tn__);
    if (! g_ptr_array_size(ls->members)) {
        emit(1, "return 0");
    } else {
        emit_start(1, "return ");
        for (unsigned int m = 0; m < g_ptr_array_size(ls->members); m++) {
            lcm_member_t *lm = (lcm_member_t *) g_ptr_array_index(ls->members, m);

            if (m) {
                emit_end(" +");
                emit_start(2, "");
            }

            if (lcm_is_primitive_type(lm->type->lctypename)) {
                emit_continue("%d", primitive_type_size(lm->type->lctypename));
            } else {
                emit_continue("p.%s.Size()",
                    first_to_upper(dots_to_underscores(lm->membername)));
            }
        }
        emit_end("");
    }
    emit(0, "}");

    free((char *)tn_);
    free((char *)tn__);

    return 0;
}

int emit_go(lcmgen_t *lcmgen)
{
    ////////////////////////////////////////////////////////////
    // ENUMS
    for (unsigned int i = 0; i < g_ptr_array_size(lcmgen->enums); i++) {

        lcm_enum_t *le = (lcm_enum_t *) g_ptr_array_index(lcmgen->enums, i);
        if (emit_go_enum(lcmgen, le))
            return -1;
    }

    ////////////////////////////////////////////////////////////
    // STRUCTS
    for (unsigned int i = 0; i < g_ptr_array_size(lcmgen->structs); i++) {
        lcm_struct_t *ls = (lcm_struct_t *) g_ptr_array_index(lcmgen->structs, i);

        if (emit_go_struct(lcmgen, ls))
            return -1;
    }

    return 0;
}
